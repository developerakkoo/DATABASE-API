let $ = function (element, selector = element) {
  if (element === selector) return document.querySelector(selector)
  else return element.querySelector(selector)
}
window.$ = $

$.html = function html (parentEl, str = parentEl) {
  let div = document.createElement('div')
  div.innerHTML = str.replace(/^\s*/, '')
  if (parentEl !== str) return parentEl.appendChild(div.firstChild)
  return div.firstChild
}

$.svg = function svg (parentEl, str = parentEl) {
  let g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
  g.innerHTML = str.replace(/^\s*/, '')
  if (parentEl !== str) return parentEl.appendChild(g.firstChild)
  return g.firstChild
}

Object.defineProperty($, 'query', {
  get: function () {
    let q = {}
    let params = document.location.search.replace(/(^\?)/, '').split('&')
    for (let param of params) {
      param = param.split('=')
      q[param[0]] = decodeURIComponent(param[1])
    }
    return q
  },
  enumerable: true,
  configurable: true
})

$.cookie = new Proxy({}, {
  ownKeys: function (target) {
    let c = []
    let cookies = document.cookie.split(';')
    for (let cookie of cookies) {
      cookie = cookie.trim().split('=')
      if (cookie[0].length === 0 || cookie[1].length === 0) continue
      c.push(cookie[0])
    }
    return c
  },
  has: function (target, name) { // this === handler object of proxy
    let keys = Object.getOwnPropertyNames($.cookie) // !!! access proxy
    if (keys.find(n => n === name)) return true
    return false
  },
  get: function (target, name) {
    if (name === 'toJSON') return function () { // this === proxy
      let j = {}
      for (let p of Object.getOwnPropertyNames(this)) j[p] = this[p]
      return j
    }
    let cookies = document.cookie.split(';')
    for (let cookie of cookies) {
      cookie = cookie.trim().split('=')
      if (cookie[0] !== name) continue
      if (cookie[1].length === 0) return undefined
      return decodeURIComponent(cookie[1])
    }
  },
  set: function (target, name, value) {
    if (typeof value === 'string')
      document.cookie = name + '=' + encodeURIComponent(value)
  },
  deleteProperty: function (target, name) {
    document.cookie = name + '='
    return true
  }
})

/*Object.defineProperty($, 'cookie', {
  get: function () {
    let c = {}
    let cookies = document.cookie.split(';')
    for (let cookie of cookies) {
      cookie = cookie.trim().split('=')
      if (cookie[0].length === 0) continue
      c[cookie[0]] = decodeURIComponent(cookie[1])
    }
    return c
  },
  enumerable: true,
  configurable: true
})*/

$.ajax = function ajax (url, async = true, user, password) {
  let xhr
  if (window.XMLHttpRequest) xhr = new window.XMLHttpRequest()
  else xhr = new window.ActiveXObject('Microsoft.XMLHTTP')

  let ajaxObj = {}
  ajaxObj.xhr = xhr
  ajaxObj.method = 'get'
  ajaxObj.url = url
  ajaxObj.async = async
  ajaxObj.user = user
  ajaxObj.password = password
  ajaxObj.headers = {}
  ajaxObj.setHeader = function (field, value) {
    this.headers[field] = value
    return this
  }

  ajaxObj.send = function sendAjax (data, cb = () => {}) { // this === ajaxObj
    xhr.open(this.method, this.url, this.async, this.user, this.password)
    if (data != null && typeof data !== 'string' && !(data instanceof window.FormData)) {
      data = JSON.stringify(data)
      xhr.setRequestHeader('Content-Type', 'application/json')
    }
    for (let f in this.headers) {
      if (this.headers[f]) xhr.setRequestHeader(f, this.headers[f])
    }

    function executor (resolve, reject) {
      xhr.onreadystatechange = function () { // this === xhr
        if (this.readyState !== 4) return // not finished yet
        ajaxObj.response = this.response
        let contType = this.getResponseHeader('Content-Type')
        if (contType && contType.includes('application/json')) {
          ajaxObj.response = JSON.parse(ajaxObj.response)
        }
        if (this.status !== 200) { // error
          let err = new Error('ajax error (status !== 200): ' +
                    this.status + ': ' + this.statusText)
          err.request = ajaxObj
          setTimeout(() => {
            cb(err, ajaxObj.response, this, ajaxObj)
          }, 0)
          reject(err)
          return
        }
        // success
        setTimeout(() => { // protection against errors in cb
          cb(null, ajaxObj.response, this, ajaxObj)
        }, 0)
        resolve(ajaxObj.response, this, ajaxObj)
      }
      xhr.send(data)
    }

    if (window.Promise) return new window.Promise(executor)
    executor(() => {}, () => {}) // just start executor if promises are not available
  }

  let methods = ['post', 'get', 'put', 'patch', 'delete']
  methods.forEach(m => {
    ajaxObj[m] = function (data, cb) {
      this.method = m
      return this.send(data, cb)
    }
  })

  return ajaxObj
}
